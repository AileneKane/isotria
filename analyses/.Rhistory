zst[199,]
rCH[199,]
zstart<-c()
i=199
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
z
rCH[199,]
z[-v] <- NA#observed states get NA
z
z[-v] <- NA#observed states get NA
length(which(ch[i,]>=3))==0
ch=rCH
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
z
w
length(which(ch[i,]>=3))==0
ch[199,]
CH2
head(CH2)
CH2[199,]
length(which(ch[i,]>=3))==0
length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2
min(ch[i,which(z==3)-1], na.rm=T)>1
ch[i,which(z==3)-1
]
ch[i,]
which(z==3)
min(ch[i,which(z==3)-1], na.rm=T)>1
min(ch[i,which(z==3)-1], na.rm=T)>1
min(ch[i,which(z==3)-1], na.rm=T
)
min(ch[i,which(z==3)-1], na.rm=T)
min(ch[i,which(z==3)]
)
min(ch[i,which(z==3)-1], na.rm=T)
length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2
ch[i,min(which(z==3))-1]==2
ch[i,min(which(z==3))-1]
ch[i,min(which(z==3))-1]
h[i,min(which(z==3))]
ch[i,min(which(z==3))]
min(which(z==3))
ch[i,min(which(z==3))]<-4
ch[i,]
z[i,min(which(z==3))]
z[min(which(z==3))]
z
z[min(which(z==3))]<-4
z
ms.init.z <- function(ch, f){#ms.init.z gives starting values of 3 or 4 to all unknown states
zstart<-c()
#matrix(data=NA,nrow=dim(ch)[1], ncol=dim(ch)[2]))
for(i in 1:dim(ch)[1]){
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{z[min(which(z==3))]<-4
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
}
#for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}#makes sure everything before and including first value is an NA
return(zstart)
}
zst=ms.init.z(rCH,f)
warning()
zst
inits<-function(){list(mean.sV=c(.5,.5), mean.sF=c(.5,.5),mean.sUV=c(.5,.5),mean.sUF=c(.5,.5),mean.fV=c(.5,.5),mean.fF=c(.5,.5),mean.fUV=c(.5,.5),mean.fUF=c(.5,.5),mean.dV=c(.5,.5),mean.dF=c(.5,.5),mean.dUV=c(.5,.5),mean.dUF=c(.5,.5),sigma.sV=c(1,1),sigma.sF=c(1,1),sigma.sUV=c(1,1),sigma.sUF=c(1,1),sigma.fV=c(1,1),sigma.fF=c(1,1),sigma.fUV=c(1,1),sigma.fUF=c(1,1),sigma.dV=c(1,1),sigma.dF=c(1,1),sigma.dUV=c(1,1),sigma.dUF=c(1,1),z = zst)}
# Parameters monitored
parameters <- c("mean.sV","mean.sF","mean.sUV","mean.sUF", "mean.fV","mean.fF","mean.fUV","mean.fUF","mean.dV","mean.dF","mean.dUV","mean.dUF","beta.sV","beta.sF", "beta.sUV","beta.sUF","beta.fV","beta.fF","beta.fUV","beta.fUF","beta.dV", "beta.dF", "beta.dUV","beta.dUF","sV0","sV1","sF0","sF1","sUV0","sUF0","sUV1","sUF1","fV0","fV1","fF0","fF1","fUV0","fUV1","fUF0","fUF1","dV0","dV1","dF0","dF1","dUV0","dUF0","dUV1","dUF1","beta1.sV","beta1.sF","beta1.sUV","beta1.sUF","beta1.fV","beta1.fF","beta1.fUV","beta1.fUF","beta1.dV", "beta1.dF","beta1.dUV","beta1.dUF","mu.sV","mu.sF","mu.sUV","mu.sUF","mu.fV","mu.fF","mu.fUV","mu.fUF","mu.dV","mu.dF","mu.dUV","mu.dUF","sigma.sV2","sigma.sF2","sigma.sUV2","sigma.sUF2","sigma.fV2","sigma.fF2","sigma.fUV2","sigma.fUF2","sigma.dV2","sigma.dF2","sigma.dUV2","sigma.dUF2")
# MCMC settings
ni <- 2500
nt <- 5
nb <- 500
nc <- 3
# Call JAGS from R #
#complex model
ms4.rf <- jags(jags.data, inits, parameters, "ms-ranef4stages.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel=T)
zst[200,]
rCH[200,]
min(ch[i,which(z==3)-1], na.rm=T)>1
i=200
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
length(which(ch[i,]>=3))==0
length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2
z[min(which(z==3))]<-4
z
z[4]
z[which(z==4]
z[which(z==4)]
rCH[200,]
z
z[which(z==4)]
which(z==4)
z[which(z==4)+1]
if(z[which(z==4)+1]==3)z[which(z==4)+1]<-4
z
ms.init.z <- function(ch, f){#ms.init.z gives starting values of 3 or 4 to all unknown states
zstart<-c()
#matrix(data=NA,nrow=dim(ch)[1], ncol=dim(ch)[2]))
for(i in 1:dim(ch)[1]){
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{z[min(which(z==3))]<-4
if(z[which(z==4)+1]==3)z[which(z==4)+1]<-4
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
}
#for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}#makes sure everything before and including first value is an NA
return(zstart)
}
zst=ms.init.z(rCH,f)
i
if(z[which(z==4)+1]==3){z[which(z==4)+1]<-4}
z[which(z==4)+1]==3
z[min(which(z==4))+1]==3
z[min(which(z==4))+1]
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{z[min(which(z==3))]<-4
if(z[min(which(z==4))+1]==3){z[which(z==4)+1]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
z
#give starting values of 3 or 4 to all unknown states
ms.init.z <- function(ch, f){#ms.init.z gives starting values of 3 or 4 to all unknown states
zstart<-c()
#matrix(data=NA,nrow=dim(ch)[1], ncol=dim(ch)[2]))
for(i in 1:dim(ch)[1]){
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{z[min(which(z==3))]<-4
if(z[min(which(z==4))+1]==3){z[which(z==4)+1]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
}
#for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}#makes sure everything before and including first value is an NA
return(zstart)
}
zst=ms.init.z(rCH,f)
i
z[min(which(z==4))+1]==3
z[min(which(z==3))]<-4
if(z[min(which(z==4))+1]==3){z[which(z==4)+1]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
z[min(which(z==4))+1]==3
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{
z[min(which(z==3))]<-4
if(z[min(which(z==4))+1]==3){z[which(z==4)+1]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
z
ms.init.z <- function(ch, f){#ms.init.z gives starting values of 3 or 4 to all unknown states
zstart<-c()
#matrix(data=NA,nrow=dim(ch)[1], ncol=dim(ch)[2]))
for(i in 1:dim(ch)[1]){
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{
z[min(which(z==3))]<-4
if(z[min(which(z==4))+1]==3){z[which(z==4)+1]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
}
#for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}#makes sure everything before and including first value is an NA
return(zstart)
}
zst=ms.init.z(rCH,f)
i
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
length(which(ch[i,]>=3))==0
length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2
z[min(which(z==3))]<-4
min(which(z==3))
ms.init.z <- function(ch, f){#ms.init.z gives starting values of 3 or 4 to all unknown states
zstart<-c()
#matrix(data=NA,nrow=dim(ch)[1], ncol=dim(ch)[2]))
for(i in 1:dim(ch)[1]){
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{
z[min(which(z==3),na.rm=T)]<-4
if(z[min(which(z==4), na.rm=T)+1]==3){z[which(z==4)+1]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
}
#for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}#makes sure everything before and including first value is an NA
return(zstart)
}
zst=ms.init.z(rCH,f)
i
z[min(which(z==4), na.rm=T)+1]==3
z[which(z==4)+1]<-4
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
min(ch[i,which(z==3)-1], na.rm=T)>1
min(ch[i,which(z==3)-1], na.rm=T)
ch[i,]
i=200
zstart<-c()
#matrix(data=NA,nrow=dim(ch)[1], ncol=dim(ch)[2]))
for(i in 1:dim(ch)[1]){
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{
z[min(which(z==3),na.rm=T)]<-4
if(z[min(which(z==4), na.rm=T)+1]==3){z[which(z==4)+1]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
}
i
ch[22,]
z<-ch[i,]
z
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
length(which(ch[i,]>=3)
length(which(ch[i,]>=3))==0
length(which(ch[i,]>=3))==0
length(which(z==3))> 0
length(which(ch[i,]==2))>0
ch[i,min(which(z==3))-1]==2
z[min(which(z==3),na.rm=T)]
min(which(z==3),na.rm=T)
z[min(which(z==3),na.rm=T)]<-4
if(z[min(which(z==4), na.rm=T)+1]==3){z[which(z==4)+1]<-4}
z[min(which(z==4), na.rm=T)+1]==3
z[min(which(z==4), na.rm=T)
min(which(z==4), na.rm=T
)
z[min(which(z==4), na.rm=T)+1]==3
z[min(which(z==4), na.rm=T)+1]
min(which(z==4), na.rm=T)
+1
z[min(which(z==4), na.rm=T)+1]
z
z
ch[i,]
!is.na(z[min(which(z==4), na.rm=T)+1])
ms.init.z <- function(ch, f){#ms.init.z gives starting values of 3 or 4 to all unknown states
zstart<-c()
#matrix(data=NA,nrow=dim(ch)[1], ncol=dim(ch)[2]))
for(i in 1:dim(ch)[1]){
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{
z[min(which(z==3),na.rm=T)]<-4
if(!is.na(z[min(which(z==4), na.rm=T)+1]) & z[min(which(z==4), na.rm=T)+1]==3){z[which(z==4)+1]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
}
#for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}#makes sure everything before and including first value is an NA
return(zstart)
}
zst=ms.init.z(rCH,f)
zstart<-c()
#matrix(data=NA,nrow=dim(ch)[1], ncol=dim(ch)[2]))
for(i in 1:dim(ch)[1]){
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{
z[min(which(z==3),na.rm=T)]<-4
if(!is.na(z[min(which(z==4), na.rm=T)+1]) & z[min(which(z==4), na.rm=T)+1]==3){z[which(z==4)+1]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
}
i
zst=ms.init.z(rCH,f)
zst
which(zst==4)
rCH[which(zst==4)]
rCH[which(zst==4)-1]
head(which(zst==4))
head(which(zst==4)-1)
rCH[(which(zst==4)-1)]
which(rCH[(which(zst==4)-1)]==1)
rCH[which(rCH[(which(zst==4)-1)]==1)]
which(rCH[(which(zst==4)-1)]==1)
rCH[1,]
zst[1,]
which(rCH[(which(zst==4)-1)]==1)
which(rCH[(which(zst==4)-1)]
)
which(rCH[(which(zst==4)-1)])
rCH[(which(zst==4)-1)]
which(zst==4)
rCH[which(zst==4)]
rCH[which(zst==4)-1]
rCH[which(zst==4)-1]
rCH[which(zst==4)]
tail(rCH)
tail(zst)
zst=ms.init.z(rCH,f)
jags.data <- list(y = rCH, f = f, n.occasions = dim(rCH)[2], nind = dim(rCH)[1], z = known.state.ms(rCH),group=group, x=time_log, x1=logged_yrs2)
# Initial values
inits<-function(){list(mean.sV=c(.5,.5), mean.sF=c(.5,.5),mean.sUV=c(.5,.5),mean.sUF=c(.5,.5),mean.fV=c(.5,.5),mean.fF=c(.5,.5),mean.fUV=c(.5,.5),mean.fUF=c(.5,.5),mean.dV=c(.5,.5),mean.dF=c(.5,.5),mean.dUV=c(.5,.5),mean.dUF=c(.5,.5),sigma.sV=c(1,1),sigma.sF=c(1,1),sigma.sUV=c(1,1),sigma.sUF=c(1,1),sigma.fV=c(1,1),sigma.fF=c(1,1),sigma.fUV=c(1,1),sigma.fUF=c(1,1),sigma.dV=c(1,1),sigma.dF=c(1,1),sigma.dUV=c(1,1),sigma.dUF=c(1,1),z = zst)}
# Parameters monitored
parameters <- c("mean.sV","mean.sF","mean.sUV","mean.sUF", "mean.fV","mean.fF","mean.fUV","mean.fUF","mean.dV","mean.dF","mean.dUV","mean.dUF","beta.sV","beta.sF", "beta.sUV","beta.sUF","beta.fV","beta.fF","beta.fUV","beta.fUF","beta.dV", "beta.dF", "beta.dUV","beta.dUF","sV0","sV1","sF0","sF1","sUV0","sUF0","sUV1","sUF1","fV0","fV1","fF0","fF1","fUV0","fUV1","fUF0","fUF1","dV0","dV1","dF0","dF1","dUV0","dUF0","dUV1","dUF1","beta1.sV","beta1.sF","beta1.sUV","beta1.sUF","beta1.fV","beta1.fF","beta1.fUV","beta1.fUF","beta1.dV", "beta1.dF","beta1.dUV","beta1.dUF","mu.sV","mu.sF","mu.sUV","mu.sUF","mu.fV","mu.fF","mu.fUV","mu.fUF","mu.dV","mu.dF","mu.dUV","mu.dUF","sigma.sV2","sigma.sF2","sigma.sUV2","sigma.sUF2","sigma.fV2","sigma.fF2","sigma.fUV2","sigma.fUF2","sigma.dV2","sigma.dF2","sigma.dUV2","sigma.dUF2")
# MCMC settings
ni <- 2500
nt <- 5
nb <- 500
nc <- 3
# Call JAGS from R #
#complex model
ms4.rf <- jags(jags.data, inits, parameters, "ms-ranef4stages.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel=T)
z[212]
zst[212,]
rCH[212,]
ms.init.z <- function(ch, f){#ms.init.z gives starting values of 3 or 4 to all unknown states
zstart<-c()
#matrix(data=NA,nrow=dim(ch)[1], ncol=dim(ch)[2]))
for(i in 1:dim(ch)[1]){
z<-ch[i,]
v <- which(z>=3)# occurences that are unknown states get 3s by default (already coded)
w<-which(z<3)
z[-v] <- NA#observed states get NA
if(length(which(ch[i,]>=3))==0){
z[w]<-NA
} else if (length(which(z==3))> 0 & length(which(ch[i,]==2))>0 & ch[i,min(which(z==3))-1]==2)
{
z[min(which(z==3),na.rm=T)]<-4
if(!is.na(z[min(which(z==4), na.rm=T)+1]) & z[min(which(z==4), na.rm=T)+1]==3){z[which(z==4)+1]<-4}
if(!is.na(z[min(which(z==4), na.rm=T)+2]) & z[min(which(z==4), na.rm=T)+2]==3){z[which(z==4)+2]<-4}
if(min(ch[i,which(z==3)-1], na.rm=T)>1){z[v]<-4}
#else if y<-which(z==4)
#x<-y-1
#q<-which(ch[i,x]==1)
#z[y[q-1]]<-3
#if(length(names(which(ch[i,y-1]==3)))>0)
# {
#  z[which(ch[i,y-1]==3)+1]<-3
# }
}
#print(i);print(ch[i,]);print(z)
zstart<-rbind(zstart,z)
}
#for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}#makes sure everything before and including first value is an NA
return(zstart)
}
zst=ms.init.z(rCH,f)
ms4.rf <- jags(jags.data, inits, parameters, "ms-ranef4stages.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel=T)
inits<-function(){list(mean.sV=c(.5,.5), mean.sF=c(.5,.5),mean.sUV=c(.5,.5),mean.sUF=c(.5,.5),mean.fV=c(.5,.5),mean.fF=c(.5,.5),mean.fUV=c(.5,.5),mean.fUF=c(.5,.5),mean.dV=c(.5,.5),mean.dF=c(.5,.5),mean.dUV=c(.5,.5),mean.dUF=c(.5,.5),sigma.sV=c(1,1),sigma.sF=c(1,1),sigma.sUV=c(1,1),sigma.sUF=c(1,1),sigma.fV=c(1,1),sigma.fF=c(1,1),sigma.fUV=c(1,1),sigma.fUF=c(1,1),sigma.dV=c(1,1),sigma.dF=c(1,1),sigma.dUV=c(1,1),sigma.dUF=c(1,1),z = zst)}
jags.data <- list(y = rCH, f = f, n.occasions = dim(rCH)[2], nind = dim(rCH)[1], z = known.state.ms(rCH),group=group, x=time_log, x1=logged_yrs2)
ms4.rf <- jags(jags.data, inits, parameters, "ms-ranef4stages.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel=T)
rCH[212,]
zst[212,]
